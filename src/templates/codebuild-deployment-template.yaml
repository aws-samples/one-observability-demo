# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0
# Workshop deployment template for CDK projects - CloudFormation
# Version: 1.0.0 - Simplified

AWSTemplateFormatVersion: '2010-09-09'
Description: |
  Automates CDK project deployment for workshop environments. Provisions S3 storage, CodeBuild project, and monitoring resources to bootstrap AWS accounts and deploy CDK applications consistently. Includes error handling and cleanup mechanisms for failed deployments. For more details, see: https://github.com/aws-samples/one-observability-demo

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Repository Configuration
        Parameters:
          - pConfigFileUrl
          - pOrganizationName
          - pRepositoryName
          - pBranchName
          - pWorkingFolder
          - pApplicationName
          - pDisableCleanup
      - Label:
          default: Enhanced Cleanup Configuration
        Parameters:
          - pCleanupMode
          - pTroubleshootingGracePeriodHours
          - pCleanupLogRetentionDays
      - Label:
          default: User Defined Tags
        Parameters:
          - pUserDefinedTagKey1
          - pUserDefinedTagValue1
          - pUserDefinedTagKey2
          - pUserDefinedTagValue2
          - pUserDefinedTagKey3
          - pUserDefinedTagValue3
          - pUserDefinedTagKey4
          - pUserDefinedTagValue4
          - pUserDefinedTagKey5
          - pUserDefinedTagValue5

Parameters:

  pDisableCleanup:
    Type: String
    Description: Disable cleanup in post_build stage if deployment fails
    Default: 'false'
    AllowedValues:
      - 'true'
      - 'false'
    ConstraintDescription: Must be either 'true' or 'false'

  pCleanupMode:
    Type: String
    Description: Cleanup behavior mode - preserve for troubleshooting or auto-cleanup
    Default: 'immediate'
    AllowedValues:
      - 'preserve'
      - 'immediate'
    ConstraintDescription: Must be either 'preserve' (keeps cleanup resources for troubleshooting) or 'immediate' (deletes everything immediately)

  pTroubleshootingGracePeriodHours:
    Type: Number
    Description: Hours to keep cleanup resources available for troubleshooting (only applies in preserve mode)
    Default: 48
    MinValue: 1
    MaxValue: 168
    ConstraintDescription: Must be between 1 and 168 hours (1 week)

  pCleanupLogRetentionDays:
    Type: Number
    Description: Days to retain cleanup logs for troubleshooting
    Default: 7
    AllowedValues: [1, 3, 5, 7, 14, 30, 60, 90, 120, 150, 180, 365, 400, 545, 731, 1827, 3653]
    ConstraintDescription: Must be a valid CloudWatch Logs retention period

  pConfigFileUrl:
    Type: String
    Description: URL to the initial configuration file
    AllowedPattern: ^https?://.*$
    ConstraintDescription: Must be a valid HTTP or HTTPS URL
    Default: https://raw.githubusercontent.com/aws-samples/one-observability-demo/refs/heads/feat/cdkpipeline/src/presets/default.env

  pOrganizationName:
    Type: String
    Description: GitHub/CodeCommit organization name
    AllowedPattern: '[A-Za-z0-9_.-]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores, periods, or hyphens
    Default: aws-samples

  pRepositoryName:
    Type: String
    Description: Repository containing the CDK code
    AllowedPattern: '[A-Za-z0-9_.-]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores, periods, or hyphens
    Default: one-observability-demo

  pBranchName:
    Type: String
    Description: Branch to deploy from
    Default: feat/cdkpipeline
    AllowedPattern: '[A-Za-z0-9_.-/]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores,
      periods, slashes, or hyphens

  pWorkingFolder:
    Type: String
    Description: Working folder for deployment
    Default: src/cdk
    AllowedPattern: '[A-Za-z0-9_.-/]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores, periods, or hyphens

  pApplicationName:
    Type: String
    Description: Application name used for tagging deployed stacks
    Default: One Observability Workshop
    AllowedPattern: ^[A-Za-z0-9\s_.-]+$
    ConstraintDescription: Must contain only alphanumeric characters, spaces, underscores, periods, or hyphens

  pUserDefinedTagKey1:
    Type: String
    Description: Key for user defined tag 1
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'
    Default: WorkshopName

  pUserDefinedTagValue1:
    Type: String
    Description: Value for user defined tag 1
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'
    Default: one-observability-demo

  pUserDefinedTagKey2:
    Type: String
    Description: Key for user defined tag 2
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'
    Default: Version

  pUserDefinedTagValue2:
    Type: String
    Description: Value for user defined tag 2
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'
    Default: 1.0.0

  pUserDefinedTagKey3:
    Type: String
    Description: Key for user defined tag 3
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'

  pUserDefinedTagValue3:
    Type: String
    Description: Value for user defined tag 3
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'

  pUserDefinedTagKey4:
    Type: String
    Description: Key for user defined tag 4
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'

  pUserDefinedTagValue4:
    Type: String
    Description: Value for user defined tag 4
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'

  pUserDefinedTagKey5:
    Type: String
    Description: Key for user defined tag 5
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'

  pUserDefinedTagValue5:
    Type: String
    Description: Value for user defined tag 5
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'



Conditions:
  # Conditions to control creation of user-defined tags
  cCreateTag1: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey1
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue1
        - ''

  cCreateTag2: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey2
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue2
        - ''

  cCreateTag3: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey3
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue3
        - ''

  cCreateTag4: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey4
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue4
        - ''

  cCreateTag5: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey5
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue5
        - ''

  # Enhanced cleanup conditions
  cPreserveCleanupResources: !Equals [!Ref pCleanupMode, 'preserve']

Resources:
  # Lambda execution role for resource cleanup
  rResourceCleanupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ResourceCleanup
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:DeleteObject
                  - s3:ListBucketVersions
                  - s3:DeleteObjectVersion
                Resource:
                  - !Sub ${rConfigBucket.Arn}/*
                  - !GetAtt rConfigBucket.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-resource-cleanup-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Lambda function to clean up resources
  rResourceCleanupFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rResourceCleanupRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          def handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      # Clean up S3 bucket
                      s3 = boto3.client('s3')
                      bucket = event['ResourceProperties']['BucketName']
                      paginator = s3.get_paginator('list_object_versions')
                      for page in paginator.paginate(Bucket=bucket):
                          delete_keys = []
                          if 'Versions' in page:
                              delete_keys.extend([{'Key': obj['Key'], 'VersionId': obj['VersionId']} for obj in page['Versions']])
                          if 'DeleteMarkers' in page:
                              delete_keys.extend([{'Key': obj['Key'], 'VersionId': obj['VersionId']} for obj in page['DeleteMarkers']])
                          if delete_keys:
                              s3.delete_objects(Bucket=bucket, Delete={'Objects': delete_keys})
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-resource-cleanup-function
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create S3 bucket to store configuration files
  rConfigBucket:
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-config-bucket
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Custom resource to clean up resources on deletion. Custom resource doesn't support tags
  rResourceCleanup:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt rResourceCleanupFunction.Arn
      BucketName: !Ref rConfigBucket
      StackName: !Ref AWS::StackName

  # Bucket policy to enforce HTTPS-only access
  rConfigBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref rConfigBucket
      PolicyDocument:
        Statement:
          - Sid: DenyInsecureConnections
            Effect: Deny
            Principal: '*'
            Action: s3:*
            Resource:
              - !GetAtt rConfigBucket.Arn
              - !Sub ${rConfigBucket.Arn}/*
            Condition:
              Bool:
                aws:SecureTransport: 'false'

  # Create uniquely named cleanup log group (the only resource we keep long-term)
  rCleanupLogGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Delete
    Properties:
      LogGroupName: !Sub /${AWS::StackName}-cleanup-log-${AWS::AccountId}-${AWS::Region}
      RetentionInDays: !Ref pCleanupLogRetentionDays
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cleanup-log
        - Key: Purpose
          Value: 'Cleanup troubleshooting and audit trail'
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
  # Create IAM role for CodeBuild project
  rCodeBuildServiceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess
      Policies:
        - PolicyName: EnhancedPipelineMonitoring
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codepipeline:ListPipelineExecutions
                  - codepipeline:GetPipelineExecution
                  - codepipeline:GetPipelineState
                  - codepipeline:ListActionExecutions
                Resource: '*'
                Condition:
                  StringEquals:
                    'aws:RequestedRegion': !Ref AWS::Region
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-codebuild-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create wait condition handle for signaling completion
  rCDKDeploymentWaitConditionHandle:
    Type: AWS::CloudFormation::WaitConditionHandle


  # Create wait condition to ensure CodeBuild project completes successfully
  rCDKDeploymentWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    Properties:
      Handle: !Ref rCDKDeploymentWaitConditionHandle
      Timeout: 3600
      Count: 1


  # Create CodeBuild project to orchestrate CDK deployment
  rCDKDeploymentProject:
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub ${AWS::StackName}-cdk-deployment
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/amazonlinux2-x86_64-standard:5.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: CONFIG_FILE_URL
            Value: !Ref pConfigFileUrl
            Type: PLAINTEXT
          - Name: CONFIG_BUCKET
            Value: !Ref rConfigBucket
            Type: PLAINTEXT
          - Name: ORGANIZATION_NAME
            Value: !Ref pOrganizationName
            Type: PLAINTEXT
          - Name: REPOSITORY_NAME
            Value: !Ref pRepositoryName
            Type: PLAINTEXT
          - Name: BRANCH_NAME
            Value: !Ref pBranchName
            Type: PLAINTEXT
          - Name: WORKING_FOLDER
            Value: !Ref pWorkingFolder
            Type: PLAINTEXT
          - Name: STACK_NAME
            Value: !Ref AWS::StackName
            Type: PLAINTEXT
          - Name: AWS_REGION
            Value: !Ref AWS::Region
            Type: PLAINTEXT
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
            Type: PLAINTEXT
          - Name: DISABLE_CLEANUP
            Value: !Ref pDisableCleanup
            Type: PLAINTEXT
      ServiceRole: !GetAtt rCodeBuildServiceRole.Arn
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            install:
              runtime-versions:
                nodejs: 22
                python: 3.12
              commands:
                - npm install -g aws-cdk
                - pip3 install git-remote-s3
            pre_build:
              commands:
                # Configure git with generic user info
                - git config --global user.email "codebuild@aws.amazon.com"
                - git config --global user.name "AWS CodeBuild"
                # Clone repository with shallow clone
                - git clone --depth 1 --branch $BRANCH_NAME https://github.com/$ORGANIZATION_NAME/$REPOSITORY_NAME.git ./repo
                - cd ./repo
                # Download configuration file and append to .env
                - curl -o ./config.env "$CONFIG_FILE_URL"
                - cat ./config.env >> ${WORKING_FOLDER}/.env
                # Run account validation script
                - ./${WORKING_FOLDER}/scripts/validate-account.sh
                # Append additional environment variables to .env file
                - |
                  cat >> ${WORKING_FOLDER}/.env << EOF
                  CONFIG_FILE_URL=$CONFIG_FILE_URL
                  CONFIG_BUCKET=$CONFIG_BUCKET
                  ORGANIZATION_NAME=$ORGANIZATION_NAME
                  REPOSITORY_NAME=$REPOSITORY_NAME
                  BRANCH_NAME=$BRANCH_NAME
                  WORKING_FOLDER=$WORKING_FOLDER
                  STACK_NAME=$STACK_NAME
                  AWS_REGION=$AWS_REGION
                  AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID
                  DISABLE_CLEANUP=$DISABLE_CLEANUP
                  EOF
                # Add only .env file to repository
                - git add ${WORKING_FOLDER}/.env -f
                - git commit -m "Add merged configuration and environment variables to .env"
                # Configure S3 remote with s3+zip protocol for CodePipeline
                - git remote add s3 s3+zip://$CONFIG_BUCKET/repo
                - git push s3 $BRANCH_NAME
                # Check if account is bootstrapped
                - |
                  STACK_EXISTS=$(aws cloudformation list-stacks --query "StackSummaries[?StackName=='CDKToolkitPetsite' && StackStatus!='DELETE_COMPLETE'].StackName" --output text)
                  STACK_DELETE_COMPLETE=$(aws cloudformation list-stacks --query "StackSummaries[?StackName=='CDKToolkitPetsite' && StackStatus=='DELETE_COMPLETE'].StackName" --output text)
                  if [ -z "$STACK_EXISTS" ] && [ -z "$STACK_DELETE_COMPLETE" ]; then
                    echo "Account not bootstrapped, bootstrapping now..."
                    cdk bootstrap aws://${AWS_ACCOUNT_ID}/${AWS_REGION} --toolkit-stack-name CDKToolkitPetsite --qualifier petsite
                  elif [ -n "$STACK_DELETE_COMPLETE" ]; then
                    echo "CDK bootstrap stack in DELETE_COMPLETE state, cleaning up resources..."
                    # Force remove ECR and S3 buckets
                    aws ecr delete-repository --repository-name "cdk-petsite-container-assets-${AWS_ACCOUNT_ID}-${AWS_REGION}" --force 2>/dev/null || true
                    bucket="cdk-petsite-assets-${AWS_ACCOUNT_ID}-${AWS_REGION}"
                    if aws s3api head-bucket --bucket "$bucket" 2>/dev/null; then
                      aws s3api delete-objects --bucket "$bucket" --delete "$(aws s3api list-object-versions --bucket "$bucket" --output json --query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}')" 2>/dev/null || true
                      aws s3api delete-objects --bucket "$bucket" --delete "$(aws s3api list-object-versions --bucket "$bucket" --output json --query '{Objects: DeleteMarkers[].{Key:Key,VersionId:VersionId}}')" 2>/dev/null || true
                      aws s3api delete-bucket --bucket "$bucket" || true
                    fi
                    # Bootstrap again
                    cdk bootstrap aws://${AWS_ACCOUNT_ID}/${AWS_REGION} a
                  else
                    STACK_STATUS=$(aws cloudformation list-stacks --query "StackSummaries[?StackName=='CDKToolkitPetsite' && StackStatus!='DELETE_COMPLETE'].StackStatus" --output text)
                    if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ]; then
                      echo "CDK bootstrap stack in ROLLBACK_COMPLETE state, cleaning up resources..."
                      # Force remove ECR and S3 buckets
                      aws ecr delete-repository --repository-name "cdk-petsite-container-assets-${AWS_ACCOUNT_ID}-${AWS_REGION}" --force 2>/dev/null || true
                      bucket="cdk-petsite-assets-${AWS_ACCOUNT_ID}-${AWS_REGION}"
                      if aws s3api head-bucket --bucket "$bucket" 2>/dev/null; then
                        aws s3api delete-objects --bucket "$bucket" --delete "$(aws s3api list-object-versions --bucket "$bucket" --output json --query '{Objects: Versions[].{Key:Key,VersionId:VersionId}}')" 2>/dev/null || true
                        aws s3api delete-objects --bucket "$bucket" --delete "$(aws s3api list-object-versions --bucket "$bucket" --output json --query '{Objects: DeleteMarkers[].{Key:Key,VersionId:VersionId}}')" 2>/dev/null || true
                        aws s3api delete-bucket --bucket "$bucket" || true
                      fi
                      # Delete the stack
                      aws cloudformation delete-stack --stack-name CDKToolkitPetsite
                      aws cloudformation wait stack-delete-complete --stack-name CDKToolkitPetsite
                      # Bootstrap again
                      cdk bootstrap aws://${AWS_ACCOUNT_ID}/${AWS_REGION} --toolkit-stack-name CDKToolkitPetsite --qualifier petsite
                    else
                      echo "CDK bootstrap stack exists with status: $STACK_STATUS"
                    fi
                  fi
            build:
              commands:
                - cd $WORKING_FOLDER
                # Install dependencies and synthesize CDK
                - npm install
                - cdk synth --quiet
                - cdk deploy --require-approval never --outputs-file cdk-outputs.json --quiet
                # Extract pipeline ARN for later use
                - PIPELINE_ARN=$(cat cdk-outputs.json | jq -r '.[] | select(has("PipelineArn")) | .PipelineArn')
                - |
                  if [ -z "$PIPELINE_ARN" ] || [ "$PIPELINE_ARN" = "null" ]; then
                    echo "ERROR: Pipeline ARN is empty or null. CDK deployment failed to create pipeline."
                    exit 1
                  fi
                - |
                  echo "Pipeline ARN: $PIPELINE_ARN"
                - PIPELINE_NAME=$(echo $PIPELINE_ARN | cut -d':' -f6)
                - |
                  echo "Pipeline Name: $PIPELINE_NAME"
                # Wait for pipeline to complete using direct status checking with retry handling
                - |
                  echo "Waiting for pipeline ${PIPELINE_NAME} execution to complete..."
                  TIMEOUT=3600  # 1 hour timeout
                  ELAPSED=0
                  SLEEP_INTERVAL=30
                  INITIAL_EXECUTION_ID=""
                  RETRY_COUNT=0
                  MAX_RETRIES=3
                  RETRY_LOOP_COUNT=0
                  MAX_RETRY_LOOPS=10

                  # Get the initial execution ID to track retries
                  INITIAL_EXECUTION_ID=$(aws codepipeline list-pipeline-executions \
                    --pipeline-name "$PIPELINE_NAME" \
                    --max-items 1 \
                    --query 'pipelineExecutionSummaries[0].pipelineExecutionId' \
                    --output text)

                  echo "Initial pipeline execution ID: $INITIAL_EXECUTION_ID"

                  while [ $ELAPSED -lt $TIMEOUT ]; do
                    # Get the most recent pipeline execution details
                    EXECUTION_DETAILS=$(aws codepipeline list-pipeline-executions \
                      --pipeline-name "$PIPELINE_NAME" \
                      --max-items 1 \
                      --query 'pipelineExecutionSummaries[0].[pipelineExecutionId,status]' \
                      --output text)

                    CURRENT_EXECUTION_ID=$(echo "$EXECUTION_DETAILS" | cut -f1)
                    EXECUTION_STATUS=$(echo "$EXECUTION_DETAILS" | cut -f2)

                    # Check if this is a new execution (retry scenario)
                    if [ "$CURRENT_EXECUTION_ID" != "$INITIAL_EXECUTION_ID" ]; then
                      RETRY_COUNT=$((RETRY_COUNT + 1))
                      echo "Detected new pipeline execution (retry #$RETRY_COUNT): $CURRENT_EXECUTION_ID"
                      INITIAL_EXECUTION_ID="$CURRENT_EXECUTION_ID"
                      RETRY_LOOP_COUNT=0  # Reset retry loop counter for new execution
                      echo "Continuing to monitor new execution..."
                    fi

                    echo "Current pipeline execution status: $EXECUTION_STATUS (ID: $CURRENT_EXECUTION_ID)"

                    case "$EXECUTION_STATUS" in
                      "Succeeded")
                        echo "Pipeline execution completed successfully!"
                        if [ $RETRY_COUNT -gt 0 ]; then
                          echo "Success achieved after $RETRY_COUNT retry(ies)"
                        fi
                        echo "Signaling CloudFormation SUCCESS"
                        WAIT_HANDLE_URL=$(aws cloudformation describe-stack-resource --stack-name $STACK_NAME --logical-resource-id rCDKDeploymentWaitConditionHandle --query 'StackResourceDetail.PhysicalResourceId' --output text --region $AWS_REGION)
                        curl -X PUT -H 'Content-Type:' --data-binary '{"Status" : "SUCCESS","Reason" : "Pipeline completed successfully","UniqueId" : "'$(uuidgen)'","Data" : "Pipeline execution finished"}' "$WAIT_HANDLE_URL"
                        break
                        ;;
                      "Failed")
                        echo "Pipeline execution failed with status: $EXECUTION_STATUS"
                        RETRY_LOOP_COUNT=$((RETRY_LOOP_COUNT + 1))
                        echo "Retry loop count: $RETRY_LOOP_COUNT/$MAX_RETRY_LOOPS"

                        if [ $RETRY_LOOP_COUNT -lt $MAX_RETRY_LOOPS ]; then
                          echo "Waiting for potential retry... (loop $RETRY_LOOP_COUNT of $MAX_RETRY_LOOPS)"
                          sleep 60
                          ELAPSED=$((ELAPSED + 60))
                          continue
                        else
                          echo "Maximum retry loops ($MAX_RETRY_LOOPS) reached without new execution. Build failed."
                          exit 1
                        fi
                        ;;
                      "Cancelled"|"Stopped")
                        echo "Pipeline execution was cancelled or stopped: $EXECUTION_STATUS"
                        echo "This may indicate manual intervention or system issues."
                        exit 1
                        ;;
                      "Superseded")
                        echo "Pipeline execution was superseded by a newer execution"
                        echo "Continuing to monitor the newer execution..."
                        sleep $SLEEP_INTERVAL
                        ELAPSED=$((ELAPSED + SLEEP_INTERVAL))
                        ;;
                      "InProgress")
                        echo "Pipeline execution in progress..."
                        sleep $SLEEP_INTERVAL
                        ELAPSED=$((ELAPSED + SLEEP_INTERVAL))
                        ;;
                      "Stopping")
                        echo "Pipeline execution is stopping..."
                        sleep $SLEEP_INTERVAL
                        ELAPSED=$((ELAPSED + SLEEP_INTERVAL))
                        ;;
                      *)
                        echo "Unknown pipeline status: $EXECUTION_STATUS"
                        echo "Continuing to monitor..."
                        sleep $SLEEP_INTERVAL
                        ELAPSED=$((ELAPSED + SLEEP_INTERVAL))
                        ;;
                    esac

                    # Additional safety check for stuck executions
                    if [ $ELAPSED -gt 0 ] && [ $((ELAPSED % 300)) -eq 0 ]; then
                      echo "Progress check: $((ELAPSED / 60)) minutes elapsed, status: $EXECUTION_STATUS"

                      # Get detailed stage information for better visibility
                      aws codepipeline get-pipeline-state \
                        --name "$PIPELINE_NAME" \
                        --query 'stageStates[*].[stageName,latestExecution.status]' \
                        --output table || echo "Could not retrieve detailed stage information"
                    fi
                  done

                  if [ $ELAPSED -ge $TIMEOUT ]; then
                    echo "Timeout reached after $((TIMEOUT / 60)) minutes"
                    echo "Final pipeline status: $EXECUTION_STATUS"
                    echo "Total retries attempted: $RETRY_COUNT"

                    # Get final pipeline state for debugging
                    echo "Final pipeline state:"
                    aws codepipeline get-pipeline-state \
                      --name "$PIPELINE_NAME" \
                      --query 'stageStates[*].[stageName,latestExecution.status,latestExecution.errorDetails.message]' \
                      --output table || echo "Could not retrieve final pipeline state"

                    exit 1
                  fi
            post_build:
              commands:
                - |
                  if [ "$CODEBUILD_BUILD_SUCCEEDING" = "0" ]; then
                    if [ "$DISABLE_CLEANUP" = "true" ]; then
                      echo "Build failed, but cleanup is disabled. Skipping resource cleanup."
                    else
                      echo "Build failed, cleaning up S3 bucket for rollback"
                      aws s3 rm s3://$CONFIG_BUCKET --recursive
                      echo "Triggering CDK stack cleanup via Step Function"
                      aws stepfunctions start-execution \
                        --state-machine-arn "arn:aws:states:$AWS_REGION:$AWS_ACCOUNT_ID:stateMachine:$STACK_NAME-cdk-cleanup" \
                        --input '{}' || echo "Failed to trigger cleanup, continuing..."
                    fi
                    WAIT_HANDLE_URL=$(aws cloudformation describe-stack-resource --stack-name $STACK_NAME --logical-resource-id rCDKDeploymentWaitConditionHandle --query 'StackResourceDetail.PhysicalResourceId' --output text --region $AWS_REGION)
                    curl -X PUT -H 'Content-Type:' --data-binary '{"Status" : "FAILURE","Reason" : "Build failed","UniqueId" : "'$(uuidgen)'","Data" : "Build execution failed"}' "$WAIT_HANDLE_URL"
                  else
                    echo "Build completed - signal already sent during pipeline monitoring"
                  fi
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-deployment
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
  # Start the CodeBuild project to begin deployment
  rStartDeployment:
    Type: Custom::StartDeployment
    DependsOn:
      - rConfigBucket
      - rCDKDeploymentWaitConditionHandle
    Properties:
      ServiceToken: !GetAtt rStartDeploymentFunction.Arn
      CodeBuildProjectName: !Ref rCDKDeploymentProject


  # Create Lambda function to start the CodeBuild project
  rStartDeploymentFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rStartDeploymentFunctionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import time

          def handler(event, context):
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      codebuild = boto3.client('codebuild')
                      project_name = event['ResourceProperties']['CodeBuildProjectName']

                      # Start the CodeBuild project
                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']

                      # Wait a few seconds to ensure the build starts
                      time.sleep(5)

                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'BuildId': build_id
                      })
                  except Exception as e:
                      print(f"Error starting CodeBuild project: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': str(e)
                      })
              else:  # Delete
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Timeout: 30
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-start-deployment-function
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create IAM role for start deployment Lambda function
  rStartDeploymentFunctionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                Resource: !GetAtt rCDKDeploymentProject.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-start-deployment-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Step Function for CDK Stack Cleanup
  rCDKCleanupStateMachine:
    Type: AWS::StepFunctions::StateMachine
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      StateMachineName: !Sub ${AWS::StackName}-cdk-cleanup
      RoleArn: !GetAtt rCDKCleanupRole.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-cleanup
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      DefinitionString: !Sub |
        {
          "Comment": "CDK Stack Cleanup State Machine",
          "StartAt": "ListTaggedStacks",
          "States": {
            "ListTaggedStacks": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${rCDKStackListerFunction}",
                "Payload": {}
              },
              "ResultPath": "$.stackList",
              "Next": "CheckStacksFound"
            },
            "CheckStacksFound": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.stackList.Payload.stacks",
                  "IsPresent": true,
                  "Next": "DeleteStacks"
                }
              ],
              "Default": "NoStacksToClean"
            },
            "DeleteStacks": {
              "Type": "Map",
              "ItemsPath": "$.stackList.Payload.stacks",
              "MaxConcurrency": 1,
              "Iterator": {
                "StartAt": "DescribeStack",
                "States": {
                  "DescribeStack": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::aws-sdk:cloudformation:describeStacks",
                    "Parameters": {
                      "StackName.$": "$"
                    },
                    "Assign": {
                      "stackInfo.$": "$.Stacks[0]"
                    },
                    "Next": "DeleteStack",
                    "Catch": [
                      {
                        "ErrorEquals": ["CloudFormation.CloudFormationException"],
                        "Next": "StackAlreadyDeleted"
                      }
                    ]
                  },
                  "DeleteStack": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::aws-sdk:cloudformation:deleteStack",
                    "Parameters": {
                      "StackName.$": "$stackInfo.StackName"
                    },
                    "Next": "WaitForDeletion",
                    "Catch": [
                      {
                        "ErrorEquals": ["States.ALL"],
                        "Next": "DeletionFailed"
                      }
                    ]
                  },
                  "WaitForDeletion": {
                    "Type": "Wait",
                    "Seconds": 30,
                    "Next": "CheckDeletionStatus"
                  },
                  "CheckDeletionStatus": {
                    "Type": "Task",
                    "Resource": "arn:aws:states:::aws-sdk:cloudformation:describeStacks",
                    "Parameters": {
                      "StackName.$": "$stackInfo.StackName"
                    },
                    "ResultPath": "$.stackStatus",
                    "Next": "EvaluateDeletionStatus",
                    "Catch": [
                      {
                        "ErrorEquals": ["CloudFormation.ValidationError", "CloudFormation.CloudFormationException"],
                        "Next": "DeletionComplete"
                      }
                    ]
                  },
                  "EvaluateDeletionStatus": {
                    "Type": "Choice",
                    "Choices": [
                      {
                        "Variable": "$.stackStatus.Stacks[0].StackStatus",
                        "StringEquals": "DELETE_IN_PROGRESS",
                        "Next": "WaitForDeletion"
                      },
                      {
                        "Variable": "$.stackStatus.Stacks[0].StackStatus",
                        "StringEquals": "DELETE_COMPLETE",
                        "Next": "DeletionComplete"
                      }
                    ],
                    "Default": "DeletionFailed"
                  },
                  "DeletionComplete": {
                    "Type": "Pass",
                    "Result": "Stack deleted successfully",
                    "End": true
                  },
                  "DeletionFailed": {
                    "Type": "Pass",
                    "Result": "Stack deletion failed or cancelled",
                    "End": true
                  },
                  "StackAlreadyDeleted": {
                    "Type": "Pass",
                    "Result": "Stack already deleted or does not exist",
                    "End": true
                  }
                }
              },
              "Next": "DeleteCDKToolkitStack"
            },
            "NoStacksToClean": {
              "Type": "Pass",
              "Result": "No tagged stacks found to clean up",
              "Next": "DeleteCDKToolkitStack"
            },
            "DeleteCDKToolkitStack": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:cloudformation:deleteStack",
              "Parameters": {
                "StackName": "CDKToolkitPetsite"
              },
              "Next": "WaitForCDKToolkitDeletion",
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "CleanupCDKStagingBucket"
                }
              ]
            },
            "WaitForCDKToolkitDeletion": {
              "Type": "Wait",
              "Seconds": 30,
              "Next": "CheckCDKToolkitDeletionStatus"
            },
            "CheckCDKToolkitDeletionStatus": {
              "Type": "Task",
              "Resource": "arn:aws:states:::aws-sdk:cloudformation:describeStacks",
              "Parameters": {
                "StackName": "CDKToolkitPetsite"
              },
              "ResultPath": "$.cdkStackStatus",
              "Next": "EvaluateCDKToolkitDeletionStatus",
              "Catch": [
                {
                  "ErrorEquals": ["CloudFormation.ValidationError", "CloudFormation.CloudFormationException"],
                  "Next": "CleanupCDKStagingBucket"
                }
              ]
            },
            "EvaluateCDKToolkitDeletionStatus": {
              "Type": "Choice",
              "Choices": [
                {
                  "Variable": "$.cdkStackStatus.Stacks[0].StackStatus",
                  "StringEquals": "DELETE_IN_PROGRESS",
                  "Next": "WaitForCDKToolkitDeletion"
                },
                {
                  "Variable": "$.cdkStackStatus.Stacks[0].StackStatus",
                  "StringEquals": "DELETE_COMPLETE",
                  "Next": "CleanupCDKStagingBucket"
                }
              ],
              "Default": "CleanupCDKStagingBucket"
            },
            "CleanupCDKStagingBucket": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${rCDKStagingBucketCleanupFunction}",
                "Payload": {}
              },
              "Next": "ComprehensiveResourceCleanup"
            },
            "ComprehensiveResourceCleanup": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${rComprehensiveResourceCleanupFunction}",
                "Payload": {}
              },
              "Next": "CleanupComplete",
              "Catch": [
                {
                  "ErrorEquals": ["States.ALL"],
                  "Next": "CleanupComplete",
                  "Comment": "Continue to cleanup completion even if comprehensive cleanup fails"
                }
              ]
            },
            "CleanupComplete": {
              "Type": "Task",
              "Resource": "arn:aws:states:::lambda:invoke",
              "Parameters": {
                "FunctionName": "${rCleanupCompletionFunction}",
                "Payload": {
                  "StackName": "${AWS::StackName}",
                  "CleanupMode": "${pCleanupMode}",
                  "GracePeriodHours": "${pTroubleshootingGracePeriodHours}"
                }
              },
              "End": true
            }
          }
        }

  # IAM Role for Step Function
  rCDKCleanupRole:
    Type: AWS::IAM::Role
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: states.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: CDKCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource: !GetAtt rCDKStackListerFunction.Arn
              - Effect: Allow
                Action:
                  - cloudformation:DescribeStacks
                Resource: "*"
              - Effect: Allow
                Action:
                  - cloudformation:DeleteStack
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                Resource:
                  - !GetAtt rCleanupCompletionFunction.Arn
                  - !GetAtt rCDKStagingBucketCleanupFunction.Arn
                  - !GetAtt rComprehensiveResourceCleanupFunction.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-cleanup-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Lambda function to list CDK stacks by tag
  rCDKStackListerFunction:
    Type: AWS::Lambda::Function
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      FunctionName: !Sub ${AWS::StackName}-cdk-stack-lister
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rCDKStackListerRole.Arn
      Timeout: 60
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-stack-lister
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      Code:
        ZipFile: !Sub |
          import boto3

          def handler(event, context):
              cf_client = boto3.client('cloudformation')
              stacks = []

              try:
                  paginator = cf_client.get_paginator('list_stacks')
                  for page in paginator.paginate(StackStatusFilter=['CREATE_COMPLETE', 'UPDATE_COMPLETE', 'DELETE_FAILED', 'ROLLBACK_COMPLETE', 'ROLLBACK_FAILED']):
                      for stack in page['StackSummaries']:
                          # Skip nested stacks
                          if 'ParentId' in stack:
                              continue

                          try:
                              # Get stack tags
                              stack_detail = cf_client.describe_stacks(StackName=stack['StackName'])
                              tags = stack_detail['Stacks'][0].get('Tags', [])

                              # Check if stack has the required application tag
                              has_app_tag = False
                              sequence_value = 1  # Default sequence value

                              for tag in tags:
                                  if tag['Key'] == 'application' and tag['Value'] == '${pApplicationName}':
                                      has_app_tag = True
                                  elif tag['Key'] == 'sequence':
                                      try:
                                          sequence_value = int(tag['Value'])
                                      except ValueError:
                                          sequence_value = 1

                              if has_app_tag:
                                  stacks.append({
                                      'name': stack['StackName'],
                                      'sequence': sequence_value
                                  })
                          except Exception as e:
                              print(f"Error checking stack {stack['StackName']}: {str(e)}")
                              continue

                  # Sort stacks by sequence in descending order (highest first)
                  stacks.sort(key=lambda x: x['sequence'], reverse=True)

                  # Return just the stack names in sorted order
                  return {'stacks': [stack['name'] for stack in stacks]}
              except Exception as e:
                  print(f"Error listing stacks: {str(e)}")
                  return {'stacks': []}

  # IAM Role for CDK Stack Lister Lambda
  rCDKStackListerRole:
    Type: AWS::IAM::Role
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CDKStackListerPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:ListStacks
                  - cloudformation:DescribeStacks
                Resource: "*"
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-stack-lister-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Lambda function to create cleanup log and schedule delayed resource cleanup
  rCleanupCompletionFunction:
    Type: AWS::Lambda::Function
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      FunctionName: !Sub ${AWS::StackName}-cleanup-completion
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rCleanupCompletionRole.Arn
      Timeout: 300
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cleanup-completion-function
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import time
          from datetime import datetime, timedelta

          def handler(event, context):
              stack_name = event.get('StackName')
              cleanup_mode = event.get('CleanupMode', 'immediate')
              grace_period_hours = int(event.get('GracePeriodHours', 48))

              if not stack_name:
                  print("No stack name provided")
                  return

              try:
                  logs_client = boto3.client('logs')
                  events_client = boto3.client('events')

                  # Use the pre-existing uniquely named cleanup log group
                  log_group_name = f"/{stack_name}-cleanup-log-${AWS::AccountId}-${AWS::Region}"

                  # Log cleanup completion with timestamp and summary
                  cleanup_summary = {
                      "timestamp": datetime.utcnow().isoformat(),
                      "stack_name": stack_name,
                      "cleanup_status": "completed",
                      "cleanup_mode": cleanup_mode,
                      "step_function_arn": f"arn:aws:states:${AWS::Region}:${AWS::AccountId}:stateMachine:{stack_name}-cdk-cleanup",
                      "cleanup_functions": [
                          f"{stack_name}-cdk-stack-lister",
                          f"{stack_name}-cleanup-completion",
                          f"{stack_name}-cdk-staging-cleanup",
                          f"{stack_name}-comprehensive-resource-cleanup"
                      ],
                      "grace_period_hours": grace_period_hours,
                      "scheduled_deletion_time": (datetime.utcnow() + timedelta(hours=grace_period_hours)).isoformat() if cleanup_mode == 'preserve' else None,
                      "troubleshooting_note": f"Cleanup resources will remain available for {grace_period_hours} hours for troubleshooting before automatic deletion" if cleanup_mode == 'preserve' else "Cleanup resources will be deleted immediately (immediate mode)"
                  }

                  try:
                      log_stream_name = f"cleanup-{int(time.time())}"
                      logs_client.create_log_stream(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name
                      )

                      logs_client.put_log_events(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name,
                          logEvents=[
                              {
                                  'timestamp': int(time.time() * 1000),
                                  'message': json.dumps(cleanup_summary, indent=2)
                              }
                          ]
                      )
                      print(f"Logged cleanup summary to {log_group_name}/{log_stream_name}")
                  except Exception as e:
                      print(f"Error creating cleanup log: {str(e)}")

                  # Only schedule delayed cleanup in preserve mode
                  if cleanup_mode == 'preserve':
                      # Schedule delayed cleanup of resources after grace period
                      cleanup_time = datetime.utcnow() + timedelta(hours=grace_period_hours)
                      schedule_expression = f"at({cleanup_time.strftime('%Y-%m-%dT%H:%M:%S')})"

                      rule_name = f"{stack_name}-delayed-cleanup"

                      try:
                          # Create EventBridge rule for delayed cleanup
                          events_client.put_rule(
                              Name=rule_name,
                              ScheduleExpression=schedule_expression,
                              Description=f"Delayed cleanup for {stack_name} cleanup resources after {grace_period_hours}-hour grace period",
                              State='ENABLED'
                          )

                          # Add target to invoke delayed cleanup function
                          events_client.put_targets(
                              Rule=rule_name,
                              Targets=[
                                  {
                                      'Id': '1',
                                      'Arn': f"arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:{stack_name}-delayed-cleanup",
                                      'Input': json.dumps({
                                          'StackName': stack_name,
                                          'LogGroupName': log_group_name
                                      })
                                  }
                              ]
                          )

                          print(f"Scheduled delayed cleanup for {cleanup_time.isoformat()} UTC")
                          print(f"Cleanup resources will remain available for troubleshooting until then")

                      except Exception as e:
                          print(f"Error scheduling delayed cleanup: {str(e)}")
                          # Fallback: still complete normally but without delayed deletion
                  else:
                      print(f"Immediate cleanup mode: cleanup resources will be deleted with stack deletion")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': 'Cleanup completed successfully',
                          'log_group': log_group_name,
                          'grace_period_hours': 48,
                          'scheduled_deletion': cleanup_time.isoformat()
                      })
                  }

              except Exception as e:
                  print(f"Error in cleanup completion: {str(e)}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }

  # IAM Role for Cleanup Completion Lambda
  rCleanupCompletionRole:
    Type: AWS::IAM::Role
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CleanupCompletionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # CloudWatch Logs permissions for creating cleanup log
              - Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                  - logs:PutRetentionPolicy
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-cleanup-log*"
              # EventBridge permissions for scheduling delayed cleanup
              - Effect: Allow
                Action:
                  - events:PutRule
                  - events:PutTargets
                Resource:
                  - !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule/${AWS::StackName}-delayed-cleanup"
              # Lambda permissions for scheduled cleanup function
              - Effect: Allow
                Action:
                  - lambda:AddPermission
                Resource: !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-delayed-cleanup"
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cleanup-completion-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Lambda function for delayed cleanup of cleanup resources (only created in preserve mode)
  rDelayedCleanupFunction:
    Type: AWS::Lambda::Function
    Condition: cPreserveCleanupResources
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      FunctionName: !Sub ${AWS::StackName}-delayed-cleanup
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rDelayedCleanupRole.Arn
      Timeout: 300
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-delayed-cleanup-function
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import time

          def handler(event, context):
              stack_name = event.get('StackName')
              log_group_name = event.get('LogGroupName')

              if not stack_name:
                  print("No stack name provided")
                  return

              try:
                  # Log final cleanup action
                  if log_group_name:
                      logs_client = boto3.client('logs')
                      try:
                          log_stream_name = f"delayed-cleanup-{int(time.time())}"
                          logs_client.create_log_stream(
                              logGroupName=log_group_name,
                              logStreamName=log_stream_name
                          )

                          cleanup_message = {
                              "timestamp": time.time(),
                              "message": f"Performing delayed cleanup of cleanup resources for {stack_name}",
                              "grace_period_expired": True,
                              "resources_being_deleted": [
                                  f"{stack_name}-cdk-cleanup",
                                  f"{stack_name}-cdk-stack-lister",
                                  f"{stack_name}-cleanup-completion",
                                  f"{stack_name}-delayed-cleanup",
                                  f"{stack_name}-delayed-cleanup-rule"
                              ]
                          }

                          logs_client.put_log_events(
                              logGroupName=log_group_name,
                              logStreamName=log_stream_name,
                              logEvents=[
                                  {
                                      'timestamp': int(time.time() * 1000),
                                      'message': json.dumps(cleanup_message, indent=2)
                                  }
                              ]
                          )
                      except Exception as e:
                          print(f"Error logging final cleanup: {str(e)}")

                  # Delete Step Function
                  try:
                      sf_client = boto3.client('stepfunctions')
                      sf_arn = f"arn:aws:states:${AWS::Region}:${AWS::AccountId}:stateMachine:{stack_name}-cdk-cleanup"
                      sf_client.delete_state_machine(stateMachineArn=sf_arn)
                      print(f"Deleted Step Function: {sf_arn}")
                  except Exception as e:
                      print(f"Error deleting Step Function: {str(e)}")

                  # Delete Lambda functions
                  lambda_client = boto3.client('lambda')
                  functions_to_delete = [
                      f"{stack_name}-cdk-stack-lister",
                      f"{stack_name}-cleanup-completion"
                  ]

                  for function_name in functions_to_delete:
                      try:
                          lambda_client.delete_function(FunctionName=function_name)
                          print(f"Deleted Lambda function: {function_name}")
                      except Exception as e:
                          print(f"Error deleting Lambda function {function_name}: {str(e)}")

                  # Delete EventBridge rule that triggered this function
                  try:
                      events_client = boto3.client('events')
                      rule_name = f"{stack_name}-delayed-cleanup"

                      # Remove targets first
                      events_client.remove_targets(
                          Rule=rule_name,
                          Ids=['1']
                      )

                      # Delete rule
                      events_client.delete_rule(Name=rule_name)
                      print(f"Deleted EventBridge rule: {rule_name}")
                  except Exception as e:
                      print(f"Error deleting EventBridge rule: {str(e)}")

                  print("Delayed cleanup completed successfully")

                  # Finally, delete this function itself
                  try:
                      lambda_client.delete_function(FunctionName=f"{stack_name}-delayed-cleanup")
                      print("Deleted delayed cleanup function")
                  except Exception as e:
                      print(f"Error deleting delayed cleanup function: {str(e)}")

              except Exception as e:
                  print(f"Error in delayed cleanup: {str(e)}")

  # IAM Role for Delayed Cleanup Lambda (only created in preserve mode)
  rDelayedCleanupRole:
    Type: AWS::IAM::Role
    Condition: cPreserveCleanupResources
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DelayedCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # CloudWatch Logs permissions for final logging
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/aws/lambda/${AWS::StackName}-cleanup-log*"
              # Step Function deletion - specific to this stack's state machine
              - Effect: Allow
                Action:
                  - states:DeleteStateMachine
                Resource: !Sub "arn:aws:states:${AWS::Region}:${AWS::AccountId}:stateMachine:${AWS::StackName}-cdk-cleanup"
              # Lambda function deletion - specific to this stack's functions
              - Effect: Allow
                Action:
                  - lambda:DeleteFunction
                Resource:
                  - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-cdk-stack-lister"
                  - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-cleanup-completion"
                  - !Sub "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:${AWS::StackName}-delayed-cleanup"
              # EventBridge rules - manage this stack's cleanup rule
              - Effect: Allow
                Action:
                  - events:RemoveTargets
                  - events:DeleteRule
                Resource: !Sub "arn:aws:events:${AWS::Region}:${AWS::AccountId}:rule:${AWS::StackName}-delayed-cleanup"
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-delayed-cleanup-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Comprehensive resource cleanup Lambda function
  rComprehensiveResourceCleanupFunction:
    Type: AWS::Lambda::Function
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      FunctionName: !Sub ${AWS::StackName}-comprehensive-resource-cleanup
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rComprehensiveResourceCleanupRole.Arn
      Timeout: 900  # 15 minutes for comprehensive cleanup
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-comprehensive-resource-cleanup-function
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      Code:
        ZipFile: !Sub |
          import boto3
          import json
          import time
          from datetime import datetime

          def handler(event, context):
              """
              Comprehensive cleanup of workshop resources by tags
              Mirrors functionality from cleanup-resources.ts script
              """

              # Initialize AWS clients
              logs_client = boto3.client('logs')
              ec2_client = boto3.client('ec2')
              rds_client = boto3.client('rds')
              ecs_client = boto3.client('ecs')
              s3_client = boto3.client('s3')
              resource_groups_client = boto3.client('resourcegroupstaggingapi')
              ssm_client = boto3.client('ssm')
              lambda_client = boto3.client('lambda')
              iam_client = boto3.client('iam')

              application_name = "${pApplicationName}"
              environment = "non-prod"

              # Log to the cleanup log group
              log_group_name = f"/${AWS::StackName}-cleanup-log-${AWS::AccountId}-${AWS::Region}"
              cleanup_results = {
                  "timestamp": datetime.utcnow().isoformat(),
                  "cleanup_type": "comprehensive_resource_cleanup",
                  "results": {}
              }

              try:
                  # 1. Clean up CloudWatch Log Groups
                  log_groups_deleted = cleanup_cloudwatch_logs(logs_client, resource_groups_client, application_name, environment)
                  cleanup_results["results"]["cloudwatch_logs"] = log_groups_deleted

                  # 2. Clean up EBS Volumes
                  ebs_volumes_deleted = cleanup_ebs_volumes(ec2_client, resource_groups_client, application_name, environment)
                  cleanup_results["results"]["ebs_volumes"] = ebs_volumes_deleted

                  # 3. Clean up EBS Snapshots
                  ebs_snapshots_deleted = cleanup_ebs_snapshots(ec2_client, resource_groups_client, application_name, environment)
                  cleanup_results["results"]["ebs_snapshots"] = ebs_snapshots_deleted

                  # 4. Clean up RDS Backups
                  rds_backups_deleted = cleanup_rds_backups(rds_client, resource_groups_client, application_name, environment)
                  cleanup_results["results"]["rds_backups"] = rds_backups_deleted

                  # 5. Clean up ECS Task Definitions
                  ecs_tasks_deleted = cleanup_ecs_task_definitions(ecs_client, resource_groups_client, application_name, environment)
                  cleanup_results["results"]["ecs_task_definitions"] = ecs_tasks_deleted

                  # 6. Clean up S3 Buckets
                  s3_buckets_deleted = cleanup_s3_buckets(s3_client, resource_groups_client, application_name, environment)
                  cleanup_results["results"]["s3_buckets"] = s3_buckets_deleted

                  # 7. Clean up SSM Parameters
                  ssm_params_deleted = cleanup_ssm_parameters(ssm_client, application_name, environment)
                  cleanup_results["results"]["ssm_parameters"] = ssm_params_deleted

                  # 8. Clean up Lambda Functions
                  lambda_functions_deleted = cleanup_lambda_functions(lambda_client, application_name, environment)
                  cleanup_results["results"]["lambda_functions"] = lambda_functions_deleted

                  # 9. Clean up IAM Roles
                  iam_roles_deleted = cleanup_iam_roles(iam_client, application_name, environment)
                  cleanup_results["results"]["iam_roles"] = iam_roles_deleted

                  # 10. Clean up IAM Policies
                  iam_policies_deleted = cleanup_iam_policies(iam_client, application_name, environment)
                  cleanup_results["results"]["iam_policies"] = iam_policies_deleted

                  total_deleted = sum(cleanup_results["results"].values())
                  cleanup_results["total_resources_deleted"] = total_deleted

                  # Log results to cleanup log group
                  try:
                      log_stream_name = f"comprehensive-cleanup-{int(time.time())}"
                      logs_client.create_log_stream(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name
                      )
                      logs_client.put_log_events(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name,
                          logEvents=[{
                              'timestamp': int(time.time() * 1000),
                              'message': json.dumps(cleanup_results, indent=2)
                          }]
                      )
                  except Exception as e:
                      print(f"Error logging comprehensive cleanup results: {str(e)}")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'message': f'Comprehensive cleanup completed. Deleted {total_deleted} resources.',
                          'details': cleanup_results["results"]
                      })
                  }

              except Exception as e:
                  error_msg = f"Error in comprehensive cleanup: {str(e)}"
                  print(error_msg)

                  # Log error
                  cleanup_results["error"] = error_msg
                  try:
                      log_stream_name = f"comprehensive-cleanup-error-{int(time.time())}"
                      logs_client.create_log_stream(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name
                      )
                      logs_client.put_log_events(
                          logGroupName=log_group_name,
                          logStreamName=log_stream_name,
                          logEvents=[{
                              'timestamp': int(time.time() * 1000),
                              'message': json.dumps(cleanup_results, indent=2)
                          }]
                      )
                  except:
                      pass

                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': error_msg})
                  }

          def get_resources_by_tags(resource_groups_client, resource_type, application_name, environment):
              """Get resources by tags using Resource Groups API"""
              try:
                  resources = []
                  paginator = resource_groups_client.get_paginator('get_resources')

                  page_iterator = paginator.paginate(
                      ResourceTypeFilters=[resource_type],
                      TagFilters=[
                          {'Key': 'application', 'Values': [application_name]},
                          {'Key': 'environment', 'Values': [environment]}
                      ]
                  )

                  for page in page_iterator:
                      if 'ResourceTagMappingList' in page:
                          for resource in page['ResourceTagMappingList']:
                              if resource.get('ResourceARN'):
                                  resources.append(resource['ResourceARN'])

                  return resources
              except Exception as e:
                  print(f"Error getting resources for {resource_type}: {str(e)}")
                  return []

          def cleanup_cloudwatch_logs(logs_client, resource_groups_client, application_name, environment):
              """Clean up CloudWatch Log Groups"""
              deleted_count = 0
              try:
                  resources = get_resources_by_tags(resource_groups_client, 'logs:log-group', application_name, environment)

                  for resource_arn in resources:
                      # Extract log group name from ARN: arn:aws:logs:region:account:log-group:NAME:*
                      log_group_name = ':'.join(resource_arn.split(':')[6:]).replace(':*', '')

                      try:
                          logs_client.delete_log_group(logGroupName=log_group_name)
                          print(f"Deleted log group: {log_group_name}")
                          deleted_count += 1
                      except Exception as e:
                          print(f"Failed to delete log group {log_group_name}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up CloudWatch logs: {str(e)}")

              return deleted_count

          def cleanup_ebs_volumes(ec2_client, resource_groups_client, application_name, environment):
              """Clean up EBS Volumes"""
              deleted_count = 0
              try:
                  resources = get_resources_by_tags(resource_groups_client, 'ec2:volume', application_name, environment)

                  for resource_arn in resources:
                      # Extract volume ID from ARN
                      volume_id = resource_arn.split('/')[-1]

                      try:
                          # Check if volume is available (not attached)
                          response = ec2_client.describe_volumes(VolumeIds=[volume_id])
                          volume = response['Volumes'][0]

                          if volume['State'] == 'available':
                              ec2_client.delete_volume(VolumeId=volume_id)
                              print(f"Deleted EBS volume: {volume_id}")
                              deleted_count += 1
                          else:
                              print(f"Skipping volume {volume_id} - state: {volume['State']}")
                      except Exception as e:
                          print(f"Failed to delete volume {volume_id}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up EBS volumes: {str(e)}")

              return deleted_count

          def cleanup_ebs_snapshots(ec2_client, resource_groups_client, application_name, environment):
              """Clean up EBS Snapshots"""
              deleted_count = 0
              try:
                  resources = get_resources_by_tags(resource_groups_client, 'ec2:snapshot', application_name, environment)

                  for resource_arn in resources:
                      # Extract snapshot ID from ARN
                      snapshot_id = resource_arn.split('/')[-1]

                      try:
                          ec2_client.delete_snapshot(SnapshotId=snapshot_id)
                          print(f"Deleted EBS snapshot: {snapshot_id}")
                          deleted_count += 1
                      except Exception as e:
                          print(f"Failed to delete snapshot {snapshot_id}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up EBS snapshots: {str(e)}")

              return deleted_count

          def cleanup_rds_backups(rds_client, resource_groups_client, application_name, environment):
              """Clean up RDS Backups (DB and Cluster Snapshots)"""
              deleted_count = 0
              try:
                  # Clean up DB snapshots
                  db_snapshots = get_resources_by_tags(resource_groups_client, 'rds:db-snapshot', application_name, environment)
                  for resource_arn in db_snapshots:
                      snapshot_id = resource_arn.split(':')[-1]
                      try:
                          rds_client.delete_db_snapshot(DBSnapshotIdentifier=snapshot_id)
                          print(f"Deleted DB snapshot: {snapshot_id}")
                          deleted_count += 1
                      except Exception as e:
                          print(f"Failed to delete DB snapshot {snapshot_id}: {str(e)}")

                  # Clean up cluster snapshots
                  cluster_snapshots = get_resources_by_tags(resource_groups_client, 'rds:cluster-snapshot', application_name, environment)
                  for resource_arn in cluster_snapshots:
                      snapshot_id = resource_arn.split(':')[-1]
                      try:
                          rds_client.delete_db_cluster_snapshot(DBClusterSnapshotIdentifier=snapshot_id)
                          print(f"Deleted cluster snapshot: {snapshot_id}")
                          deleted_count += 1
                      except Exception as e:
                          print(f"Failed to delete cluster snapshot {snapshot_id}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up RDS backups: {str(e)}")

              return deleted_count

          def cleanup_ecs_task_definitions(ecs_client, resource_groups_client, application_name, environment):
              """Clean up ECS Task Definitions"""
              deleted_count = 0
              try:
                  resources = get_resources_by_tags(resource_groups_client, 'ecs:task-definition', application_name, environment)

                  for task_definition_arn in resources:
                      try:
                          ecs_client.deregister_task_definition(taskDefinition=task_definition_arn)
                          print(f"Deregistered task definition: {task_definition_arn}")
                          deleted_count += 1
                      except Exception as e:
                          print(f"Failed to deregister task definition {task_definition_arn}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up ECS task definitions: {str(e)}")

              return deleted_count

          def cleanup_s3_buckets(s3_client, resource_groups_client, application_name, environment):
              """Clean up S3 Buckets"""
              deleted_count = 0
              try:
                  resources = get_resources_by_tags(resource_groups_client, 's3:bucket', application_name, environment)

                  for resource_arn in resources:
                      # Extract bucket name from ARN
                      bucket_name = resource_arn.split(':::')[-1]

                      try:
                          # Empty bucket first
                          empty_s3_bucket(s3_client, bucket_name)

                          # Delete bucket
                          s3_client.delete_bucket(Bucket=bucket_name)
                          print(f"Deleted S3 bucket: {bucket_name}")
                          deleted_count += 1
                      except Exception as e:
                          print(f"Failed to delete bucket {bucket_name}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up S3 buckets: {str(e)}")

              return deleted_count

          def empty_s3_bucket(s3_client, bucket_name):
              """Empty S3 bucket of all objects and versions"""
              try:
                  paginator = s3_client.get_paginator('list_object_versions')

                  for page in paginator.paginate(Bucket=bucket_name):
                      delete_keys = []

                      if 'Versions' in page:
                          delete_keys.extend([
                              {'Key': obj['Key'], 'VersionId': obj['VersionId']}
                              for obj in page['Versions']
                          ])

                      if 'DeleteMarkers' in page:
                          delete_keys.extend([
                              {'Key': obj['Key'], 'VersionId': obj['VersionId']}
                              for obj in page['DeleteMarkers']
                          ])

                      if delete_keys:
                          s3_client.delete_objects(
                              Bucket=bucket_name,
                              Delete={'Objects': delete_keys}
                          )
              except Exception as e:
                  print(f"Error emptying bucket {bucket_name}: {str(e)}")

          def cleanup_ssm_parameters(ssm_client, application_name, environment):
              """Clean up SSM Parameters"""
              deleted_count = 0
              try:
                  paginator = ssm_client.get_paginator('get_parameters_by_path')

                  for page in paginator.paginate(Path='/', Recursive=True):
                      if 'Parameters' in page:
                          for parameter in page['Parameters']:
                              parameter_name = parameter['Name']

                              try:
                                  # Check if parameter has workshop tags
                                  tags_response = ssm_client.list_tags_for_resource(
                                      ResourceType='Parameter',
                                      ResourceId=parameter_name
                                  )

                                  tags = {tag['Key']: tag['Value'] for tag in tags_response.get('TagList', [])}

                                  if (tags.get('application') == application_name and
                                      tags.get('environment') == environment):

                                      ssm_client.delete_parameter(Name=parameter_name)
                                      print(f"Deleted SSM parameter: {parameter_name}")
                                      deleted_count += 1

                              except Exception as e:
                                  print(f"Failed to delete parameter {parameter_name}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up SSM parameters: {str(e)}")

              return deleted_count

          def cleanup_lambda_functions(lambda_client, application_name, environment):
              """Clean up Lambda Functions"""
              deleted_count = 0
              try:
                  paginator = lambda_client.get_paginator('list_functions')

                  for page in paginator.paginate():
                      if 'Functions' in page:
                          for function in page['Functions']:
                              function_name = function['FunctionName']
                              function_arn = function['FunctionArn']

                              try:
                                  # Get function tags
                                  tags_response = lambda_client.get_function(FunctionName=function_arn)
                                  tags = tags_response.get('Tags', {})

                                  if (tags.get('application') == application_name and
                                      tags.get('environment') == environment):

                                      lambda_client.delete_function(FunctionName=function_name)
                                      print(f"Deleted Lambda function: {function_name}")
                                      deleted_count += 1

                              except Exception as e:
                                  print(f"Failed to delete function {function_name}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up Lambda functions: {str(e)}")

              return deleted_count

          def cleanup_iam_roles(iam_client, application_name, environment):
              """Clean up IAM Roles"""
              deleted_count = 0
              try:
                  paginator = iam_client.get_paginator('list_roles')

                  for page in paginator.paginate():
                      if 'Roles' in page:
                          for role in page['Roles']:
                              role_name = role['RoleName']

                              try:
                                  # Get role tags
                                  role_detail = iam_client.get_role(RoleName=role_name)
                                  tags = {tag['Key']: tag['Value'] for tag in role_detail.get('Role', {}).get('Tags', [])}

                                  if (tags.get('application') == application_name and
                                      tags.get('environment') == environment):

                                      # Detach managed policies
                                      attached_policies = iam_client.list_attached_role_policies(RoleName=role_name)
                                      for policy in attached_policies.get('AttachedPolicies', []):
                                          iam_client.detach_role_policy(
                                              RoleName=role_name,
                                              PolicyArn=policy['PolicyArn']
                                          )

                                      # Delete inline policies
                                      inline_policies = iam_client.list_role_policies(RoleName=role_name)
                                      for policy_name in inline_policies.get('PolicyNames', []):
                                          iam_client.delete_role_policy(
                                              RoleName=role_name,
                                              PolicyName=policy_name
                                          )

                                      # Delete role
                                      iam_client.delete_role(RoleName=role_name)
                                      print(f"Deleted IAM role: {role_name}")
                                      deleted_count += 1

                              except Exception as e:
                                  print(f"Failed to delete role {role_name}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up IAM roles: {str(e)}")

              return deleted_count

          def cleanup_iam_policies(iam_client, application_name, environment):
              """Clean up IAM Policies"""
              deleted_count = 0
              try:
                  paginator = iam_client.get_paginator('list_policies')

                  for page in paginator.paginate(Scope='Local'):  # Only customer-managed policies
                      if 'Policies' in page:
                          for policy in page['Policies']:
                              policy_name = policy['PolicyName']
                              policy_arn = policy['Arn']

                              try:
                                  # Get policy tags
                                  policy_detail = iam_client.get_policy(PolicyArn=policy_arn)
                                  tags = {tag['Key']: tag['Value'] for tag in policy_detail.get('Policy', {}).get('Tags', [])}

                                  if (tags.get('application') == application_name and
                                      tags.get('environment') == environment):

                                      iam_client.delete_policy(PolicyArn=policy_arn)
                                      print(f"Deleted IAM policy: {policy_name}")
                                      deleted_count += 1

                              except Exception as e:
                                  print(f"Failed to delete policy {policy_name}: {str(e)}")

              except Exception as e:
                  print(f"Error cleaning up IAM policies: {str(e)}")

              return deleted_count

  # Lambda function to clean up CDK staging bucket
  rCDKStagingBucketCleanupFunction:
    Type: AWS::Lambda::Function
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      FunctionName: !Sub ${AWS::StackName}-cdk-staging-cleanup
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rCDKStagingBucketCleanupRole.Arn
      Timeout: 300
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-staging-cleanup-function
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      Code:
        ZipFile: !Sub |
          import boto3
          import json

          def handler(event, context):
              s3_client = boto3.client('s3')
              account_id = '${AWS::AccountId}'
              region = '${AWS::Region}'
              bucket_name = f'cdk-petsite-assets-{account_id}-{region}'

              try:
                  # Check if bucket exists
                  try:
                      s3_client.head_bucket(Bucket=bucket_name)
                      print(f"Found CDK staging bucket: {bucket_name}")
                  except s3_client.exceptions.NoSuchBucket:
                      print(f"CDK staging bucket {bucket_name} does not exist")
                      return {'statusCode': 200, 'body': 'Bucket does not exist'}

                  # List and delete all objects
                  paginator = s3_client.get_paginator('list_object_versions')
                  delete_keys = []

                  for page in paginator.paginate(Bucket=bucket_name):
                      # Delete object versions
                      if 'Versions' in page:
                          for obj in page['Versions']:
                              delete_keys.append({'Key': obj['Key'], 'VersionId': obj['VersionId']})

                      # Delete delete markers
                      if 'DeleteMarkers' in page:
                          for obj in page['DeleteMarkers']:
                              delete_keys.append({'Key': obj['Key'], 'VersionId': obj['VersionId']})

                  # Delete objects in batches
                  if delete_keys:
                      for i in range(0, len(delete_keys), 1000):
                          batch = delete_keys[i:i+1000]
                          s3_client.delete_objects(
                              Bucket=bucket_name,
                              Delete={'Objects': batch}
                          )
                      print(f"Deleted {len(delete_keys)} objects from {bucket_name}")

                  # Delete the bucket
                  s3_client.delete_bucket(Bucket=bucket_name)
                  print(f"Deleted CDK staging bucket: {bucket_name}")

                  return {'statusCode': 200, 'body': f'Successfully cleaned up {bucket_name}'}

              except Exception as e:
                  print(f"Error cleaning up CDK staging bucket: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}

  # IAM Role for Comprehensive Resource Cleanup Lambda (Tag-Restricted)
  rComprehensiveResourceCleanupRole:
    Type: AWS::IAM::Role
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-comprehensive-resource-cleanup-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue
      Policies:
        - PolicyName: ComprehensiveResourceCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              # Resource Groups Tagging API permissions (requires wildcard for discovery)
              - Effect: Allow
                Action:
                  - tag:GetResources
                  - resource-groups:*
                Resource: "*"

              # CloudWatch Logs permissions (tag-restricted where possible)
              - Effect: Allow
                Action:
                  - logs:DescribeLogGroups
                  - logs:ListTagsLogGroup
                Resource: "*"
              - Effect: Allow
                Action:
                  - logs:DeleteLogGroup
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"
              - Effect: Allow
                Action:
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource: !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:log-group:/${AWS::StackName}-cleanup-log-${AWS::AccountId}-${AWS::Region}*"

              # EC2 permissions for EBS volumes and snapshots (tag-restricted)
              - Effect: Allow
                Action:
                  - ec2:DescribeVolumes
                  - ec2:DescribeSnapshots
                Resource: "*"
              - Effect: Allow
                Action:
                  - ec2:DeleteVolume
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"
              - Effect: Allow
                Action:
                  - ec2:DeleteSnapshot
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"

              # RDS permissions for backups (tag-restricted)
              - Effect: Allow
                Action:
                  - rds:DescribeDBSnapshots
                  - rds:DescribeDBClusterSnapshots
                Resource: "*"
              - Effect: Allow
                Action:
                  - rds:DeleteDBSnapshot
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"
              - Effect: Allow
                Action:
                  - rds:DeleteDBClusterSnapshot
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"

              # ECS permissions for task definitions (limited tag support, keep broader for discovery)
              - Effect: Allow
                Action:
                  - ecs:ListTaskDefinitions
                  - ecs:DescribeTaskDefinition
                  - ecs:DeregisterTaskDefinition
                Resource: "*"

              # S3 permissions for buckets (tag-restricted where possible)
              - Effect: Allow
                Action:
                  - s3:ListAllMyBuckets
                Resource: "*"
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:ListBucketVersions
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"
              - Effect: Allow
                Action:
                  - s3:DeleteObject
                  - s3:DeleteObjectVersion
                  - s3:DeleteBucket
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"

              # SSM permissions for parameters (tag-restricted)
              - Effect: Allow
                Action:
                  - ssm:DescribeParameters
                  - ssm:GetParametersByPath
                Resource: "*"
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                  - ssm:DeleteParameter
                  - ssm:ListTagsForResource
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"

              # Lambda permissions for functions (tag-restricted)
              - Effect: Allow
                Action:
                  - lambda:ListFunctions
                Resource: "*"
              - Effect: Allow
                Action:
                  - lambda:GetFunction
                  - lambda:DeleteFunction
                  - lambda:ListTags
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"

              # IAM permissions for roles and policies (tag-restricted where supported)
              - Effect: Allow
                Action:
                  - iam:ListRoles
                  - iam:ListPolicies
                Resource: "*"
              - Effect: Allow
                Action:
                  - iam:GetRole
                  - iam:DeleteRole
                  - iam:ListAttachedRolePolicies
                  - iam:DetachRolePolicy
                  - iam:ListRolePolicies
                  - iam:DeleteRolePolicy
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"
              - Effect: Allow
                Action:
                  - iam:GetPolicy
                  - iam:DeletePolicy
                Resource: "*"
                Condition:
                  StringEquals:
                    "aws:ResourceTag/application": !Ref pApplicationName
                    "aws:ResourceTag/environment": "non-prod"

  # IAM Role for CDK Staging Bucket Cleanup Lambda
  rCDKStagingBucketCleanupRole:
    Type: AWS::IAM::Role
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CDKStagingBucketCleanupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:ListBucketVersions
                  - s3:DeleteObject
                  - s3:DeleteObjectVersion
                  - s3:DeleteBucket
                Resource:
                  - !Sub 'arn:aws:s3:::cdk-petsite-assets-${AWS::AccountId}-${AWS::Region}'
                  - !Sub 'arn:aws:s3:::cdk-petsite-assets-${AWS::AccountId}-${AWS::Region}/*'
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-staging-bucket-cleanup-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # EventBridge Rule for Stack Deletion
  rStackDeletionRule:
    Type: AWS::Events::Rule
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      Description: Trigger cleanup when stack is being deleted
      EventPattern:
        source: ["aws.cloudformation"]
        detail-type: ["CloudFormation Stack Status Change"]
        detail:
          stack-id: [!Ref "AWS::StackId"]
          status-details:
            status: ["DELETE_IN_PROGRESS"]
      State: ENABLED
      Targets:
        - Arn: !GetAtt rCDKCleanupStateMachine.Arn
          Id: "CDKCleanupTarget"
          RoleArn: !GetAtt rEventBridgeRole.Arn

  # IAM Role for EventBridge to invoke Step Function
  rEventBridgeRole:
    Type: AWS::IAM::Role
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: StepFunctionExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - states:StartExecution
                Resource: !GetAtt rCDKCleanupStateMachine.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-eventbridge-role
        - Key: application
          Value: !Ref pApplicationName
        - Key: environment
          Value: non-prod
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue


Outputs:
  oConfigBucketName:
    Description: Name of the S3 bucket storing configuration files
    Value: !Ref rConfigBucket
    Export:
      Name: !Sub ${AWS::StackName}-ConfigBucketName

  oCodeBuildProjectName:
    Description: Name of the CodeBuild project orchestrating CDK deployment
    Value: !Ref rCDKDeploymentProject
    Export:
      Name: !Sub ${AWS::StackName}-CodeBuildProjectName

  oDeploymentStatus:
    Description: Status of the CDK deployment
    Value: !Sub Check CodeBuild project ${rCDKDeploymentProject} for deployment status
    Export:
      Name: !Sub ${AWS::StackName}-DeploymentStatus

  oCDKCleanupStateMachine:
    Description: ARN of the Step Function that handles CDK stack cleanup
    Value: !GetAtt rCDKCleanupStateMachine.Arn
    Export:
      Name: !Sub ${AWS::StackName}-CDKCleanupStateMachine

  oRepositoryInfo:
    Description: Repository information used for deployment
    Value: !Sub 'Organization: ${pOrganizationName}, Repository: ${pRepositoryName},
      Branch: ${pBranchName}'
    Export:
      Name: !Sub ${AWS::StackName}-RepositoryInfo
