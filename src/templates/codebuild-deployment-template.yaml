# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: MIT-0
# Workshop deployment template for CDK projects - CloudFormation
# Version: 1.0.0

AWSTemplateFormatVersion: '2010-09-09'
Description: |
  This CloudFormation template automates the deployment of AWS Cloud Development Kit (CDK) projects for workshop environments. It creates the necessary infrastructure to bootstrap AWS accounts for CDK usage, clone source code repositories, and deploy CDK applications in a consistent and repeatable manner. The template provisions an S3 bucket for configuration storage, a CodeBuild project that handles the CDK deployment process, and monitoring resources to track deployment status. This solution simplifies workshop setup by eliminating manual bootstrapping steps and ensuring consistent deployments across multiple participant accounts. It supports both GitHub and CodeCommit repositories as source code locations and includes error handling for failed deployments. The template is designed to be flexible enough to accommodate various workshop scenarios while providing a standardized deployment experience for workshop facilitators and participants.

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: Repository Configuration
        Parameters:
          - pConfigFileUrl
          - pOrganizationName
          - pRepositoryName
          - pBranchName
          - pWorkingFolder
      - Label:
          default: User Defined Tags
        Parameters:
          - pUserDefinedTagKey1
          - pUserDefinedTagValue1
          - pUserDefinedTagKey2
          - pUserDefinedTagValue2
          - pUserDefinedTagKey3
          - pUserDefinedTagValue3
          - pUserDefinedTagKey4
          - pUserDefinedTagValue4
          - pUserDefinedTagKey5
          - pUserDefinedTagValue5

Parameters:
  pConfigFileUrl:
    Type: String
    Description: URL to the initial configuration file
    AllowedPattern: ^https?://.*$
    ConstraintDescription: Must be a valid HTTP or HTTPS URL
    Default: https://raw.githubusercontent.com/aws-samples/one-observability-demo/refs/heads/feat/cdkpipeline/typedoc.json

  pOrganizationName:
    Type: String
    Description: GitHub/CodeCommit organization name
    AllowedPattern: '[A-Za-z0-9_.-]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores, periods, or hyphens
    Default: aws-samples

  pRepositoryName:
    Type: String
    Description: Repository containing the CDK code
    AllowedPattern: '[A-Za-z0-9_.-]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores, periods, or hyphens
    Default: one-observability-demo

  pBranchName:
    Type: String
    Description: Branch to deploy from
    Default: feat/cdkpipeline
    AllowedPattern: '[A-Za-z0-9_.-/]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores,
      periods, slashes, or hyphens

  pWorkingFolder:
    Type: String
    Description: Working folder for deployment
    Default: src/cdk
    AllowedPattern: '[A-Za-z0-9_.-/]+'
    ConstraintDescription: Must contain only alphanumeric characters, underscores, periods, or hyphens

  pUserDefinedTagKey1:
    Type: String
    Description: Key for user defined tag 1
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'
    Default: WorkshopName

  pUserDefinedTagValue1:
    Type: String
    Description: Value for user defined tag 1
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'
    Default: one-observability-demo

  pUserDefinedTagKey2:
    Type: String
    Description: Key for user defined tag 2
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'
    Default: Version

  pUserDefinedTagValue2:
    Type: String
    Description: Value for user defined tag 2
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'
    Default: 1.0.0

  pUserDefinedTagKey3:
    Type: String
    Description: Key for user defined tag 3
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'

  pUserDefinedTagValue3:
    Type: String
    Description: Value for user defined tag 3
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'

  pUserDefinedTagKey4:
    Type: String
    Description: Key for user defined tag 4
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'

  pUserDefinedTagValue4:
    Type: String
    Description: Value for user defined tag 4
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'

  pUserDefinedTagKey5:
    Type: String
    Description: Key for user defined tag 5
    AllowedPattern: ^(?!aws:)[A-Za-z0-9\s_.:=+-@/]{0,128}
    ConstraintDescription: 'Must match the allowable values for a Tag Key. This can
      only contain alphanumeric characters or special characters ( _ . : / = + -
      or @) up to 128 characters'

  pUserDefinedTagValue5:
    Type: String
    Description: Value for user defined tag 5
    AllowedPattern: ^[\w\s_.:=+-@/]{0,256}$
    ConstraintDescription: 'Must match the allowable values for a Tag Value. This
      can only contain alphanumeric characters or special characters ( _ . : / =
      + - or @) up to 256 characters'

Conditions:
  # Conditions to control creation of user-defined tags
  cCreateTag1: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey1
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue1
        - ''

  cCreateTag2: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey2
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue2
        - ''

  cCreateTag3: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey3
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue3
        - ''

  cCreateTag4: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey4
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue4
        - ''

  cCreateTag5: !And
    - !Not
      - !Equals
        - !Ref pUserDefinedTagKey5
        - ''
    - !Not
      - !Equals
        - !Ref pUserDefinedTagValue5
        - ''

Resources:
  # Lambda execution role for resource cleanup
  rResourceCleanupRole:
    Metadata:
      cdk_nag:
        rules_to_suppress:
          - id: AwsSolutions-IAM4
            reason: AWS managed policies are acceptable for a Lambda function
          - id: AwsSolutions-IAM5
            reason: Wildcard is needed since stack name is automatically generated
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ResourceCleanup
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:DeleteObject
                  - s3:ListBucketVersions
                  - s3:DeleteObjectVersion
                Resource:
                  - !Sub ${rConfigBucket.Arn}/*
                  - !GetAtt rConfigBucket.Arn
              - Effect: Allow
                Action:
                  - events:DeleteRule
                  - events:RemoveTargets
                  - events:ListTargetsByRule
                Resource: !Sub arn:${AWS::Partition}:events:${AWS::Region}:${AWS::AccountId}:rule/${AWS::StackName}-pipeline-monitor
              - Effect: Allow
                Action:
                  - lambda:RemovePermission
                Resource: !Sub arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:${rPipelineStatusFunction}

  # Lambda function to clean up resources
  rResourceCleanupFunction:
    # checkov:skip=CKV_AWS_117:Custom Resource Lambda only interacts with AWS endpoints, VPC is not needed
    # checkov:skip=CKV_AWS_116:DLQ will increase complexity, this is not needed just to signal CFN deployment since it will time-out
    # checkov:skip=CKV_AWS_173:Custom Resource Lambda, encryption is not included for simplicity
    # checkov:skip=CKV_AWS_115:Function is executed only once, no need for concurrency configurations
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rResourceCleanupRole.Arn
      Timeout: 300
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          def handler(event, context):
              try:
                  if event['RequestType'] == 'Delete':
                      # Clean up S3 bucket
                      s3 = boto3.client('s3')
                      bucket = event['ResourceProperties']['BucketName']
                      paginator = s3.get_paginator('list_object_versions')
                      for page in paginator.paginate(Bucket=bucket):
                          delete_keys = []
                          if 'Versions' in page:
                              delete_keys.extend([{'Key': obj['Key'], 'VersionId': obj['VersionId']} for obj in page['Versions']])
                          if 'DeleteMarkers' in page:
                              delete_keys.extend([{'Key': obj['Key'], 'VersionId': obj['VersionId']} for obj in page['DeleteMarkers']])
                          if delete_keys:
                              s3.delete_objects(Bucket=bucket, Delete={'Objects': delete_keys})

                      # Clean up EventBridge rule
                      events = boto3.client('events')
                      lambda_client = boto3.client('lambda')
                      stack_name = event['ResourceProperties']['StackName']
                      rule_name = f"{stack_name}-pipeline-monitor"
                      function_name = f"{stack_name}-pipeline-status-function"

                      try:
                          # Remove targets first
                          events.remove_targets(Rule=rule_name, Ids=['1'])
                          # Delete the rule
                          events.delete_rule(Name=rule_name)
                          # Remove Lambda permission
                          lambda_client.remove_permission(
                              FunctionName=function_name,
                              StatementId=rule_name
                          )
                      except Exception as e:
                          print(f"EventBridge cleanup error (non-fatal): {e}")

                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              except Exception as e:
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, str(e))

  # Create S3 bucket to store configuration files
  rConfigBucket:
    # checkov:skip=CKV_AWS_18:Bucket used to trigger CodePipeline, access logs are not needed
    # checkov:skip=CKV_AWS_21:Bucket used to trigger CodePipeline, object versioning is not needed
    Metadata:
      cdk_nag:
        rules_to_suppress:
          - id: AwsSolutions-S1
            reason: Bucket used to trigger CodePipeline, access logs are not needed
    Type: AWS::S3::Bucket
    Properties:
      VersioningConfiguration:
        Status: Enabled
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-config-bucket
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Custom resource to clean up resources on deletion
  rResourceCleanup:
    Type: AWS::CloudFormation::CustomResource
    Properties:
      ServiceToken: !GetAtt rResourceCleanupFunction.Arn
      BucketName: !Ref rConfigBucket
      StackName: !Ref AWS::StackName

  # Bucket policy to enforce HTTPS-only access
  rConfigBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref rConfigBucket
      PolicyDocument:
        Statement:
          - Sid: DenyInsecureConnections
            Effect: Deny
            Principal: '*'
            Action: s3:*
            Resource:
              - !GetAtt rConfigBucket.Arn
              - !Sub ${rConfigBucket.Arn}/*
            Condition:
              Bool:
                aws:SecureTransport: 'false'

  # Create IAM role for CodeBuild project
  rCodeBuildServiceRole:
    Metadata:
      cdk_nag:
        rules_to_suppress:
          - id: AwsSolutions-IAM4
            reason: AWS managed policies are acceptable for a CodeBuild project
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: codebuild.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/AdministratorAccess
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-codebuild-role
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create wait condition handle for signaling completion
  rCDKDeploymentWaitConditionHandle:
    Type: AWS::CloudFormation::WaitConditionHandle

  # Create wait condition to ensure CodeBuild project completes successfully
  rCDKDeploymentWaitCondition:
    Type: AWS::CloudFormation::WaitCondition
    Properties:
      Handle: !Ref rCDKDeploymentWaitConditionHandle
      Timeout: 3600
      Count: 1

  # Create CodeBuild project to orchestrate CDK deployment
  rCDKDeploymentProject:
    Metadata:
      cdk_nag:
        rules_to_suppress:
          - id: AwsSolutions-CB4
            reason: CodeBuild Project is used to kickoff the initial CDK deployment. AWS KMS
              is not required
    Type: AWS::CodeBuild::Project
    Properties:
      Name: !Sub ${AWS::StackName}-cdk-deployment
      Artifacts:
        Type: NO_ARTIFACTS
      Environment:
        Type: LINUX_CONTAINER
        ComputeType: BUILD_GENERAL1_SMALL
        Image: aws/codebuild/amazonlinux2-x86_64-standard:5.0
        PrivilegedMode: true
        EnvironmentVariables:
          - Name: CONFIG_FILE_URL
            Value: !Ref pConfigFileUrl
            Type: PLAINTEXT
          - Name: CONFIG_BUCKET
            Value: !Ref rConfigBucket
            Type: PLAINTEXT
          - Name: ORGANIZATION_NAME
            Value: !Ref pOrganizationName
            Type: PLAINTEXT
          - Name: REPOSITORY_NAME
            Value: !Ref pRepositoryName
            Type: PLAINTEXT
          - Name: BRANCH_NAME
            Value: !Ref pBranchName
            Type: PLAINTEXT
          - Name: WORKING_FOLDER
            Value: !Ref pWorkingFolder
            Type: PLAINTEXT
          - Name: STACK_NAME
            Value: !Ref AWS::StackName
            Type: PLAINTEXT
          - Name: AWS_REGION
            Value: !Ref AWS::Region
            Type: PLAINTEXT
          - Name: AWS_ACCOUNT_ID
            Value: !Ref AWS::AccountId
            Type: PLAINTEXT
      ServiceRole: !GetAtt rCodeBuildServiceRole.Arn
      Source:
        Type: NO_SOURCE
        BuildSpec: |
          version: 0.2
          phases:
            install:
              runtime-versions:
                nodejs: 22
                python: 3.12
              commands:
                - npm install -g aws-cdk
                - pip3 install git-remote-s3
            pre_build:
              commands:
                # Configure git with generic user info
                - git config --global user.email "codebuild@aws.amazon.com"
                - git config --global user.name "AWS CodeBuild"
                # Clone repository with shallow clone
                - git clone --depth 1 --branch $BRANCH_NAME https://github.com/$ORGANIZATION_NAME/$REPOSITORY_NAME.git ./repo
                - cd ./repo
                # Download configuration file to repository root
                - curl -o ./config.json "$CONFIG_FILE_URL"
                # Create .env file with all environment variables
                - |
                  cat > .env << EOF
                  CONFIG_FILE_URL=$CONFIG_FILE_URL
                  CONFIG_BUCKET=$CONFIG_BUCKET
                  ORGANIZATION_NAME=$ORGANIZATION_NAME
                  REPOSITORY_NAME=$REPOSITORY_NAME
                  BRANCH_NAME=$BRANCH_NAME
                  WORKING_FOLDER=$WORKING_FOLDER
                  STACK_NAME=$STACK_NAME
                  AWS_REGION=$AWS_REGION
                  AWS_ACCOUNT_ID=$AWS_ACCOUNT_ID
                  EOF
                # Add config file and .env file to repository
                - git add config.json .env -f
                - git commit -m "Add configuration file from $CONFIG_FILE_URL and environment variables"
                # Configure S3 remote with s3+zip protocol for CodePipeline
                - git remote add s3 s3+zip://$CONFIG_BUCKET/repo
                - git push s3 $BRANCH_NAME
                # Check if account is bootstrapped
                - |
                  if ! aws cloudformation describe-stacks --stack-name CDKToolkit > /dev/null 2>&1; then
                    echo "Account not bootstrapped, bootstrapping now..."
                    cdk bootstrap
                  else
                    STACK_STATUS=$(aws cloudformation describe-stacks --stack-name CDKToolkit --query 'Stacks[0].StackStatus' --output text)
                    if [ "$STACK_STATUS" = "ROLLBACK_COMPLETE" ]; then
                      echo "CDK bootstrap stack in ROLLBACK_COMPLETE state, cleaning up resources..."
                      # Force remove ECR and S3 buckets
                      aws ecr describe-repositories --query 'repositories[?repositoryName.starts_with(@, `cdk-`)].[repositoryName]' --output text | xargs -I {} aws ecr delete-repository --repository-name {} --force || true
                      aws s3 ls | grep cdk- | awk '{print $3}' | xargs -I {} aws s3 rb s3://{} --force || true
                      # Delete the stack
                      aws cloudformation delete-stack --stack-name CDKToolkit
                      aws cloudformation wait stack-delete-complete --stack-name CDKToolkit
                      # Bootstrap again
                      cdk bootstrap
                    fi
                  fi
            build:
              commands:
                - cd $WORKING_FOLDER
                # Install dependencies and deploy
                - npm install
                - cdk deploy --require-approval never --outputs-file cdk-outputs.json
                # Extract pipeline ARN for later use
                - PIPELINE_ARN=$(cat cdk-outputs.json | jq -r '.[] | select(has("PipelineArn")) | .PipelineArn')
                - |
                  if [ -z "$PIPELINE_ARN" ] || [ "$PIPELINE_ARN" = "null" ]; then
                    echo "ERROR: Pipeline ARN is empty or null. CDK deployment failed to create pipeline."
                    exit 1
                  fi
                - echo "Pipeline ARN $PIPELINE_ARN"
                - PIPELINE_NAME=$(echo $PIPELINE_ARN | cut -d'/' -f2)
                - echo "Pipeline Name $PIPELINE_NAME"
                # Create EventBridge rule for this specific pipeline
                - |
                  aws events put-rule \
                    --name "${STACK_NAME}-pipeline-monitor" \
                    --description "Monitor specific CDK pipeline execution status" \
                    --event-pattern '{"source":["aws.codepipeline"],"detail-type":["CodePipeline Pipeline Execution State Change"],"detail":{"state":["SUCCEEDED","FAILED"],"pipeline":["'$PIPELINE_NAME'"]}}' \
                    --state ENABLED
                - |
                  aws events put-targets \
                    --rule "${STACK_NAME}-pipeline-monitor" \
                    --targets "Id=1,Arn=arn:aws:lambda:${AWS_REGION}:${AWS_ACCOUNT_ID}:function:${STACK_NAME}-pipeline-status-function"
                - |
                  aws lambda add-permission \
                    --function-name "${STACK_NAME}-pipeline-status-function" \
                    --statement-id "${STACK_NAME}-pipeline-monitor" \
                    --action lambda:InvokeFunction \
                    --principal events.amazonaws.com \
                    --source-arn "arn:aws:events:${AWS_REGION}:${AWS_ACCOUNT_ID}:rule/${STACK_NAME}-pipeline-monitor" || true
            post_build:
              commands:
                - |
                  if [ "$CODEBUILD_BUILD_SUCCEEDING" = "0" ]; then
                    echo "Build failed, cleaning up S3 bucket for rollback"
                    aws s3 rm s3://$CONFIG_BUCKET --recursive
                  else
                    echo "CDK deployment completed"
                    PIPELINE_ARN=$(cat /tmp/pipeline_arn.txt || echo "")
                    echo "Pipeline ARN ${PIPELINE_ARN:-not found}"
                    aws cloudformation signal-resource --stack-name $STACK_NAME --logical-resource-id rCDKDeploymentWaitCondition --unique-id $(uuidgen) --status SUCCESS --region $AWS_REGION
                  fi
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-cdk-deployment
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create IAM role for Lambda function
  rPipelineStatusFunctionRole:
    Metadata:
      cdk_nag:
        rules_to_suppress:
          - id: AwsSolutions-IAM4
            reason: AWS managed policies are acceptable for a Lambda function
          - id: AwsSolutions-IAM5
            reason: Wildcard is needed since stack name is automatically generated
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CloudFormationSignalAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - cloudformation:SignalResource
                Resource: !Sub arn:${AWS::Partition}:cloudformation:${AWS::Region}:${AWS::AccountId}:stack/${AWS::StackName}/*
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                Resource: !GetAtt rCDKDeploymentProject.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-lambda-role
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create Lambda function to handle pipeline status events
  rPipelineStatusFunction:
    # checkov:skip=CKV_AWS_117:Custom Resource Lambda only interacts with AWS endpoints, VPC is not needed
    # checkov:skip=CKV_AWS_116:DLQ will increase complexity, this is not needed just to signal CFN deployment since it will time-out
    # checkov:skip=CKV_AWS_173:Custom Resource Lambda, encryption is not included for simplicity
    # checkov:skip=CKV_AWS_115:Function is executed only once, no need for concurrency configurations
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      FunctionName: !Sub ${AWS::StackName}-pipeline-status-function # Required to prevent a circular dependency
      Role: !GetAtt rPipelineStatusFunctionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import os

          def handler(event, context):
              cloudformation = boto3.client('cloudformation')

              print('Event:', json.dumps(event, indent=2))

              pipeline_state = event['detail']['state']
              stack_name = os.environ['STACK_NAME']
              logical_resource_id = os.environ['LOGICAL_RESOURCE_ID']

              if pipeline_state == 'SUCCEEDED':
                  # Signal success to CloudFormation
                  cloudformation.signal_resource(
                      StackName=stack_name,
                      LogicalResourceId=logical_resource_id,
                      UniqueId=event['id'],
                      Status='SUCCESS'
                  )
                  print('Signaled SUCCESS to CloudFormation')

              elif pipeline_state == 'FAILED':
                  # Signal failure to CloudFormation
                  cloudformation.signal_resource(
                      StackName=stack_name,
                      LogicalResourceId=logical_resource_id,
                      UniqueId=event['id'],
                      Status='FAILURE'
                  )
                  print('Signaled FAILURE to CloudFormation')

                  # Run CodeBuild project to destroy resources
                  codebuild = boto3.client('codebuild')
                  codebuild.start_build(
                      projectName=os.environ['CODEBUILD_PROJECT_NAME'],
                      environmentVariablesOverride=[
                          {
                              'name': 'DESTROY_MODE',
                              'value': 'true'
                          }
                      ]
                  )
                  print('Started CodeBuild project to destroy resources')

              return {
                  'statusCode': 200,
                  'body': json.dumps('Function executed successfully')
              }
      Environment:
        Variables:
          STACK_NAME: !Ref AWS::StackName
          LOGICAL_RESOURCE_ID: rCDKDeploymentWaitCondition
          CODEBUILD_PROJECT_NAME: !Ref rCDKDeploymentProject
      Timeout: 60
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-pipeline-status-function
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create EventBridge rule to monitor CodeBuild failures
  rCodeBuildFailureRule:
    Type: AWS::Events::Rule
    Properties:
      Description: Monitor CodeBuild project failures
      EventPattern:
        source:
          - aws.codebuild
        detail-type:
          - CodeBuild Build State Change
        detail:
          build-status:
            - FAILED
            - FAULT
            - STOPPED
            - TIMED_OUT
          project-name:
            - !Ref rCDKDeploymentProject
      State: ENABLED
      Targets:
        - Arn: !GetAtt rCodeBuildFailureFunction.Arn
          Id: CodeBuildFailureFunction

  # Create Lambda function to handle CodeBuild failures
  rCodeBuildFailureFunction:
    # checkov:skip=CKV_AWS_117:Custom Resource Lambda only interacts with AWS endpoints, VPC is not needed
    # checkov:skip=CKV_AWS_116:DLQ will increase complexity, this is not needed just to signal CFN deployment since it will time-out
    # checkov:skip=CKV_AWS_173:Custom Resource Lambda, encryption is not included for simplicity
    # checkov:skip=CKV_AWS_115:Function is executed only once, no need for concurrency configurations
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rPipelineStatusFunctionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import os

          def handler(event, context):
              cloudformation = boto3.client('cloudformation')

              print('CodeBuild failure event:', json.dumps(event, indent=2))

              build_status = event['detail']['build-status']
              stack_name = os.environ['STACK_NAME']
              logical_resource_id = os.environ['LOGICAL_RESOURCE_ID']

              # Signal failure to CloudFormation to trigger rollback
              cloudformation.signal_resource(
                  StackName=stack_name,
                  LogicalResourceId=logical_resource_id,
                  UniqueId=event['id'],
                  Status='FAILURE'
              )

              print('Signaled FAILURE to CloudFormation due to CodeBuild failure')

              return {
                  'statusCode': 200,
                  'body': json.dumps('CodeBuild failure handled')
              }
      Environment:
        Variables:
          STACK_NAME: !Ref AWS::StackName
          LOGICAL_RESOURCE_ID: rCDKDeploymentWaitCondition
      Timeout: 60
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-codebuild-failure-function
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Allow EventBridge to invoke the CodeBuild failure Lambda function
  rCodeBuildFailureFunctionPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !Ref rCodeBuildFailureFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt rCodeBuildFailureRule.Arn

  # Start the CodeBuild project to begin deployment
  rStartDeployment:
    Type: Custom::StartDeployment
    DependsOn:
      - rConfigBucket
      - rCDKDeploymentWaitConditionHandle
    Properties:
      ServiceToken: !GetAtt rStartDeploymentFunction.Arn
      CodeBuildProjectName: !Ref rCDKDeploymentProject

  # Create Lambda function to start the CodeBuild project
  rStartDeploymentFunction:
    # checkov:skip=CKV_AWS_117:Custom Resource Lambda only interacts with AWS endpoints, VPC is not needed
    # checkov:skip=CKV_AWS_116:DLQ will increase complexity, this is not needed just to signal CFN deployment since it will time-out
    # checkov:skip=CKV_AWS_173:Custom Resource Lambda, encryption is not included for simplicity
    # checkov:skip=CKV_AWS_115:Function is executed only once, no need for concurrency configurations
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.13
      Handler: index.handler
      Role: !GetAtt rStartDeploymentFunctionRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import time

          def handler(event, context):
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      codebuild = boto3.client('codebuild')
                      project_name = event['ResourceProperties']['CodeBuildProjectName']

                      # Start the CodeBuild project
                      response = codebuild.start_build(projectName=project_name)
                      build_id = response['build']['id']

                      # Wait a few seconds to ensure the build starts
                      time.sleep(5)

                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'BuildId': build_id
                      })
                  except Exception as e:
                      print(f"Error starting CodeBuild project: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': str(e)
                      })
              else:  # Delete
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Timeout: 30
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-start-deployment-function
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

  # Create IAM role for start deployment Lambda function
  rStartDeploymentFunctionRole:
    Metadata:
      cdk_nag:
        rules_to_suppress:
          - id: AwsSolutions-IAM4
            reason: Use of AWSLambdaBasicExecutionRole is acceptable here
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - !Sub arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: CodeBuildAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - codebuild:StartBuild
                Resource: !GetAtt rCDKDeploymentProject.Arn
      Tags:
        - Key: Name
          Value: !Sub ${AWS::StackName}-start-deployment-role
        - !If
          - cCreateTag1
          - Key: !Ref pUserDefinedTagKey1
            Value: !Ref pUserDefinedTagValue1
          - !Ref AWS::NoValue
        - !If
          - cCreateTag2
          - Key: !Ref pUserDefinedTagKey2
            Value: !Ref pUserDefinedTagValue2
          - !Ref AWS::NoValue
        - !If
          - cCreateTag3
          - Key: !Ref pUserDefinedTagKey3
            Value: !Ref pUserDefinedTagValue3
          - !Ref AWS::NoValue
        - !If
          - cCreateTag4
          - Key: !Ref pUserDefinedTagKey4
            Value: !Ref pUserDefinedTagValue4
          - !Ref AWS::NoValue
        - !If
          - cCreateTag5
          - Key: !Ref pUserDefinedTagKey5
            Value: !Ref pUserDefinedTagValue5
          - !Ref AWS::NoValue

Outputs:
  oConfigBucketName:
    Description: Name of the S3 bucket storing configuration files
    Value: !Ref rConfigBucket
    Export:
      Name: !Sub ${AWS::StackName}-ConfigBucketName

  oCodeBuildProjectName:
    Description: Name of the CodeBuild project orchestrating CDK deployment
    Value: !Ref rCDKDeploymentProject
    Export:
      Name: !Sub ${AWS::StackName}-CodeBuildProjectName

  oDeploymentStatus:
    Description: Status of the CDK deployment
    Value: !Sub Check CodeBuild project ${rCDKDeploymentProject} for deployment status
    Export:
      Name: !Sub ${AWS::StackName}-DeploymentStatus

  oRepositoryInfo:
    Description: Repository information used for deployment
    Value: !Sub 'Organization: ${pOrganizationName}, Repository: ${pRepositoryName},
      Branch: ${pBranchName}'
    Export:
      Name: !Sub ${AWS::StackName}-RepositoryInfo